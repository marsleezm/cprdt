package loria.rc;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.PropertiesCredentials;
import com.amazonaws.services.ec2.AmazonEC2;
import com.amazonaws.services.ec2.AmazonEC2Client;
import com.amazonaws.services.ec2.model.AuthorizeSecurityGroupIngressRequest;
import com.amazonaws.services.ec2.model.CancelSpotInstanceRequestsRequest;
import com.amazonaws.services.ec2.model.CreateSecurityGroupRequest;
import com.amazonaws.services.ec2.model.DescribeInstanceStatusRequest;
import com.amazonaws.services.ec2.model.DescribeInstanceStatusResult;
import com.amazonaws.services.ec2.model.DescribeInstancesResult;
import com.amazonaws.services.ec2.model.DescribeSpotInstanceRequestsRequest;
import com.amazonaws.services.ec2.model.DescribeSpotInstanceRequestsResult;
import com.amazonaws.services.ec2.model.Instance;
import com.amazonaws.services.ec2.model.InstanceStatus;
import com.amazonaws.services.ec2.model.InstanceType;
import com.amazonaws.services.ec2.model.IpPermission;
import com.amazonaws.services.ec2.model.LaunchSpecification;
import com.amazonaws.services.ec2.model.Placement;
import com.amazonaws.services.ec2.model.RequestSpotInstancesRequest;
import com.amazonaws.services.ec2.model.RequestSpotInstancesResult;
import com.amazonaws.services.ec2.model.Reservation;
import com.amazonaws.services.ec2.model.RunInstancesRequest;
import com.amazonaws.services.ec2.model.RunInstancesResult;
import com.amazonaws.services.ec2.model.SpotInstanceRequest;
import com.amazonaws.services.ec2.model.SpotPlacement;
import com.amazonaws.services.ec2.model.TerminateInstancesRequest;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import loria.rc.jobs.ClientModifierBenchmarkJob;
import swift.dc.DCConstants;

/**
 * toolkit to deploy on amazon EC2
 *
 * @author Stephane Martin <stephane.martin@loria.fr>
 */
public class AmazonMachine {

    static AWSCredentials credentials = null;
    public static final String SECURITYGROUPNAME = "SecurityGroupEws";
    public static final String AMIID = "ami-1beded6f";
    public static final String INSTANCETYPE = "t1.micro";
    public static final String PRICE = "0.02";
    public static final String KEYPAIR = "martins";
    public static final int REFRESH = 3000;
    public final String placement;
    private AmazonEC2 ec2;
    private LinkedList<String> instanceIds = new LinkedList();
    private LinkedList<String> newInstanceIds = new LinkedList();
    private ArrayList<String> spotInstanceRequestIds;
    private LinkedList<InetAddress> adresseMachine = new LinkedList();
    private LinkedList<String> adresseDnsMachine = new LinkedList();
    private LinkedList<Instance> instances = new LinkedList();

    /**
     * Public constructor.
     *
     * @throws Exception
     */
    public AmazonMachine(String placement, String endPoint) throws Exception {
        init();
        this.placement = placement;
        ec2.setEndpoint(endPoint);

    }

    public AmazonMachine() throws Exception {
        init();
        this.placement = "eu-west-1b";
        ec2.setEndpoint("ec2.eu-west-1.amazonaws.com");

    }

    /**
     * The only information needed to create a client are security credentials
     * consisting of the AWS Access Key ID and Secret Access Key. All other
     * configuration, such as the service endpoints, are performed
     * automatically. Client parameters, such as proxies, can be specified in an
     * optional ClientConfiguration object when constructing a client.
     *
     * @see com.amazonaws.auth.BasicAWSCredentials
     * @see com.amazonaws.auth.PropertiesCredentials
     * @see com.amazonaws.ClientConfiguration
     */
    private void init() throws Exception {
        credentials = new PropertiesCredentials(
                AmazonMachine.class.getResourceAsStream("AwsCredentials.properties"));

        ec2 = new AmazonEC2Client(credentials);

    }

    enum Protocol {

        tcp, udp, icmp
    }

    private IpPermission genIpPermission(String ipRange, Protocol protocol, int port) {
        ArrayList<String> ipsRange = new ArrayList<String>();
        ipsRange.add(ipRange);
        IpPermission ipPermission = new IpPermission();
        ipPermission.setIpProtocol(protocol.toString());
        ipPermission.setFromPort(new Integer(port));
        ipPermission.setToPort(new Integer(port));
        ipPermission.setIpRanges(ipsRange);
        return ipPermission;
    }

    public void checkAndCreateSecurityGroup() throws Exception {
        try {
            CreateSecurityGroupRequest securityGroupRequest = new CreateSecurityGroupRequest(SECURITYGROUPNAME, "This group is generated by " + this.getClass().getCanonicalName());
            ec2.createSecurityGroup(securityGroupRequest);
        } catch (AmazonServiceException ase) { //Group is already created
            return;
        }
        String ipAddr = "0.0.0.0/0";


        try {
            InetAddress addr = InetAddress.getLocalHost();

            // Get IP Address
            ipAddr = addr.getHostAddress() + "/10";
        } catch (UnknownHostException e) {
        }
        ArrayList<String> ipRanges = new ArrayList<String>();
        ipRanges.add(ipAddr);

        ArrayList<IpPermission> ipPermissions = new ArrayList<IpPermission>();

        /*
         * SSH 
         */
        ipPermissions.add(genIpPermission("0.0.0.0/0", Protocol.tcp, 22));
        /*
         * Remote Control
         */
        ipPermissions.add(genIpPermission("0.0.0.0/0", Protocol.tcp, RemoteControl.PORT));
        /*
         * 
         * swift 
         */
        ipPermissions.add(genIpPermission("0.0.0.0/0", Protocol.tcp, DCConstants.SEQUENCER_PORT));
        ipPermissions.add(genIpPermission("0.0.0.0/0", Protocol.tcp, DCConstants.SURROGATE_PORT));


        // try {
        // Authorize the ports to the used.
        AuthorizeSecurityGroupIngressRequest ingressRequest = new AuthorizeSecurityGroupIngressRequest(SECURITYGROUPNAME, ipPermissions);
        ec2.authorizeSecurityGroupIngress(ingressRequest);
        /*} catch (AmazonServiceException ase) {
         // Ignore because this likely means the zone has already been authorized.
         System.out.println(ase.getMessage());
         }*/
    }

    public void startInstanceRequest(int nb) throws UnknownHostException {
        RunInstancesRequest ir = new RunInstancesRequest();
        ir.withInstanceType(InstanceType.T1Micro);
        ir.withImageId(AMIID);
        ir.withSecurityGroups(SECURITYGROUPNAME);
        ir.withMinCount(nb);
        ir.withMaxCount(nb);
        if (KEYPAIR != null) {
            ir.withKeyName(KEYPAIR);
        }
        ir.withPlacement(new Placement(placement));

        RunInstancesResult runInstance = ec2.runInstances(ir);
        //runInstance.getReservation().getInstances();
        // ec2.startInstances(null)

        for (Instance i : runInstance.getReservation().getInstances()) {
            this.instanceIds.add(i.getInstanceId());
            this.newInstanceIds.add(i.getInstanceId());
            this.instances.add(i);
           
        }


    }

    String getInstancePublicDnsName(String instanceId) {
        DescribeInstancesResult describeInstancesRequest = ec2.describeInstances();
        List<Reservation> reservations = describeInstancesRequest.getReservations();
        //Set<Instance> allInstances = new HashSet<Instance>();
        for (Reservation reservation : reservations) {
            for (Instance instance : reservation.getInstances()) {
                if (instance.getInstanceId().equals(instanceId)) {
                    return instance.getPublicDnsName();
                }
            }
        }
        return null;
    }

    /**
     * The submit method will create 1 x one-time t1.micro request with a
     * maximum bid PRICE of $0.03 using the Amazon Linux AMI.
     *
     * Note the AMI id may change after the release of this code sample, and it
     * is important to use the latest. You can find the latest version by
     * logging into the AWS Management console, and attempting to perform a
     * launch. You will be presented with AMI options, one of which will be
     * Amazon Linux. Simply use that AMI id.
     */
    public void submitRequests() {
        //==========================================================================//
        //================= Submit a Spot Instance Request =====================//
        //==========================================================================//

        // Initializes a Spot Instance Request

        RequestSpotInstancesRequest requestRequest = new RequestSpotInstancesRequest();

        // Request 1 x t1.micro instance with a bid PRICE of $0.03. 
        //requestRequest.setSpotPrice("0.02");
        requestRequest.setSpotPrice(PRICE);
        requestRequest.setInstanceCount(Integer.valueOf(1));

        // Setup the specifications of the launch. This includes the instance type (e.g. t1.micro)
        // and the latest Amazon Linux AMI id available. Note, you should always use the latest 
        // Amazon Linux AMI id or another of your choosing.
        LaunchSpecification launchSpecification = new LaunchSpecification();
        launchSpecification.setImageId(AMIID);

        launchSpecification.setInstanceType(INSTANCETYPE);


        //setPlacement
        SpotPlacement spotPlacement = new SpotPlacement(placement);
        launchSpecification.setPlacement(spotPlacement);



        // Add the security group to the request.
        ArrayList<String> securityGroups = new ArrayList<String>();
        securityGroups.add(SECURITYGROUPNAME);
        launchSpecification.setSecurityGroups(securityGroups);
        if (KEYPAIR != null) {
            launchSpecification.setKeyName(KEYPAIR);
        }
        // Add the launch specifications to the request.
        requestRequest.setLaunchSpecification(launchSpecification);

        // Call the RequestSpotInstance API. 

        RequestSpotInstancesResult requestResult = ec2.requestSpotInstances(requestRequest);
        List<SpotInstanceRequest> requestResponses = requestResult.getSpotInstanceRequests();

        // Setup an arraylist to collect all of the request ids we want to watch hit the running
        // state.
        spotInstanceRequestIds = new ArrayList<String>();

        // Add all of the request ids to the hashset, so we can determine when they hit the 
        // active state.
        for (SpotInstanceRequest requestResponse : requestResponses) {
            System.out.println("Created Spot Request: " + requestResponse.getSpotInstanceRequestId());
            spotInstanceRequestIds.add(requestResponse.getSpotInstanceRequestId());
        }
        /*StartInstancesRequest startr = new StartInstancesRequest();
         startr.setInstanceIds(spotInstanceRequestIds);
         ec2.startInstances(startr);*/
    }

    public void waitAllLauched() {
        DescribeInstanceStatusRequest describeInstanceRequest = new DescribeInstanceStatusRequest().withInstanceIds(this.newInstanceIds);
        DescribeInstanceStatusResult describeInstanceResult;// = ec2.describeInstanceStatus(describeInstanceRequest);
        List<InstanceStatus> state;//= describeInstanceResult.getInstanceStatuses();
        int launched = 0;
        do {
            try {
                Thread.sleep(REFRESH);
            } catch (InterruptedException ex) {
            }

            describeInstanceResult = ec2.describeInstanceStatus(describeInstanceRequest);
            state = describeInstanceResult.getInstanceStatuses();
            launched = 0;

            for (InstanceStatus is : state) {
                if (is.getSystemStatus().getStatus().equals("ok")) {
                    launched++;
                }
            }
        } while (launched < newInstanceIds.size());
        for(String id:newInstanceIds){
         String dns;
            do {
                dns = getInstancePublicDnsName(id);
                Logger.getLogger(ClientModifierBenchmarkJob.class.getName()).info("add Machine waiting dns...");
            } while (dns.equals(""));
            InetAddress addr=null;
            try {
                this.adresseDnsMachine.add(dns);
                addr = InetAddress.getByName(dns);
                this.adresseMachine.add(addr);
            } catch (UnknownHostException ex) {
                Logger.getLogger(AmazonMachine.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            Logger.getLogger(ClientModifierBenchmarkJob.class.getName()).info("add Machine " + dns + " : " + addr.getHostAddress());
        }
        newInstanceIds.clear();
    }

    public boolean instanceIsLauched() {

        DescribeInstanceStatusRequest describeInstanceRequest = new DescribeInstanceStatusRequest().withInstanceIds(this.instanceIds);
        DescribeInstanceStatusResult describeInstanceResult = ec2.describeInstanceStatus(describeInstanceRequest);
        List<InstanceStatus> state = describeInstanceResult.getInstanceStatuses();

        /*while (state.size() < 1) {
         try {
         Thread.sleep(5000);
         } catch (InterruptedException ex) {
         }
         // Do nothing, just wait, have thread sleep if needed
         describeInstanceResult = ec2.describeInstanceStatus(describeInstanceRequest);
         state = describeInstanceResult.getInstanceStatuses();
         }*/
        for (int i = 0; i < 100; i++) {
            System.out.println("---");
            for (InstanceStatus is : state) {
                System.out.println("" + is.getSystemStatus().getStatus());
                System.out.println("" + is.getInstanceStatus().getStatus());
                System.out.println("" + is.getInstanceState().getName() + ":" + is.getInstanceState().getCode());
            }
            try {
                Thread.sleep(5000);
            } catch (InterruptedException ex) {
            }
            describeInstanceResult = ec2.describeInstanceStatus(describeInstanceRequest);
            state = describeInstanceResult.getInstanceStatuses();
        }
        //String status = state.get(0).getInstanceState().getName();

        return true;
    }

    /**
     * The areOpen method will determine if any of the requests that were
     * started are still in the open state. If all of them have transitioned to
     * either active, cancelled, or closed, then this will return false.
     *
     * @return
     */
    public boolean areAnyOpen() {
        //==========================================================================//
        //============== Describe Spot Instance Requests to determine =============//
        //==========================================================================//

        // Create the describeRequest with tall of the request id to monitor (e.g. that we started).
        DescribeSpotInstanceRequestsRequest describeRequest = new DescribeSpotInstanceRequestsRequest();
        describeRequest.setSpotInstanceRequestIds(spotInstanceRequestIds);

        System.out.println("Checking to determine if Spot Bids have reached the active state...");

        // Initialize variables.


        try {
            // Retrieve all of the requests we want to monitor. 
            DescribeSpotInstanceRequestsResult describeResult = ec2.describeSpotInstanceRequests(describeRequest);
            List<SpotInstanceRequest> describeResponses = describeResult.getSpotInstanceRequests();

            // Look through each request and determine if they are all in the active state.
            for (SpotInstanceRequest describeResponse : describeResponses) {
                System.out.println(" " + describeResponse.getSpotInstanceRequestId()
                        + " is in the " + describeResponse.getState() + " state.");

                // If the state is open, it hasn't changed since we attempted to request it.
                // There is the potential for it to transition almost immediately to closed or
                // cancelled so we compare against open instead of active.
                if (describeResponse.getState().equals("open")) {
                    return true;
                }

                // Add the instance id to the list we will eventually terminate.
                instanceIds.add(describeResponse.getInstanceId());
            }
        } catch (AmazonServiceException e) {
            // Print out the error.
            System.out.println("Error when calling describeSpotInstances");
            System.out.println("Caught Exception: " + e.getMessage());
            System.out.println("Reponse Status Code: " + e.getStatusCode());
            System.out.println("Error Code: " + e.getErrorCode());
            System.out.println("Request ID: " + e.getRequestId());

            // If we have an exception, ensure we don't break out of the loop.
            // This prevents the scenario where there was blip on the wire.
            return true;
        }

        return false;
    }

    public void cleanupInstances() {
        try {
            // Terminate instances.
            System.out.println("Terminate instances");
            TerminateInstancesRequest terminateRequest = new TerminateInstancesRequest(instanceIds);
            ec2.terminateInstances(terminateRequest);
        } catch (AmazonServiceException e) {
            // Write out any exceptions that may have occurred.
            System.out.println("Error terminating instances");
            System.out.println("Caught Exception: " + e.getMessage());
            System.out.println("Reponse Status Code: " + e.getStatusCode());
            System.out.println("Error Code: " + e.getErrorCode());
            System.out.println("Request ID: " + e.getRequestId());
        }

        // Delete all requests and instances that we have terminated.
        instanceIds.clear();
    }

    /**
     * The cleanup method will cancel and active requests and terminate any
     * running instances that were created using this object.
     */
    public void cleanupSpot() {
        //==========================================================================//
        //================= Cancel/Terminate Your Spot Request =====================//
        //==========================================================================//
        try {
            // Cancel requests.
            System.out.println("Cancelling requests.");
            CancelSpotInstanceRequestsRequest cancelRequest = new CancelSpotInstanceRequestsRequest(spotInstanceRequestIds);
            ec2.cancelSpotInstanceRequests(cancelRequest);
        } catch (AmazonServiceException e) {
            // Write out any exceptions that may have occurred.
            System.out.println("Error cancelling instances");
            System.out.println("Caught Exception: " + e.getMessage());
            System.out.println("Reponse Status Code: " + e.getStatusCode());
            System.out.println("Error Code: " + e.getErrorCode());
            System.out.println("Request ID: " + e.getRequestId());
        }


        spotInstanceRequestIds.clear();
        cleanupInstances();
    }

    public List<InetAddress> getInetAddress() {
        return this.adresseMachine;
    }

    public LinkedList<String> getAdresseDnsMachine() {
        return adresseDnsMachine;
    }
    
}
// public static 

